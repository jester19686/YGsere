/**
 * üñºÔ∏è WORKER THREAD –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
 * 
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç CPU-–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ,
 * –Ω–µ –±–ª–æ–∫–∏—Ä—É—è –æ—Å–Ω–æ–≤–Ω–æ–π –ø–æ—Ç–æ–∫ –±–æ—Ç–∞
 */

const { expose } = require('threads/worker');
const axios = require('axios');
const sharp = require('sharp');

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
const PROCESSING_CONFIG = {
  // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  maxWidth: 2048,
  maxHeight: 2048,
  
  // –ö–∞—á–µ—Å—Ç–≤–æ —Å–∂–∞—Ç–∏—è
  quality: 85,
  
  // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
  supportedFormats: ['jpeg', 'jpg', 'png', 'webp', 'gif'],
  
  // –¢–∞–π–º–∞—É—Ç—ã
  downloadTimeout: 30000,
  processingTimeout: 60000,
  
  // –†–∞–∑–º–µ—Ä—ã –¥–ª—è –ø—Ä–µ–≤—å—é
  thumbnailSize: 512
};

/**
 * –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ worker thread
 */
class ImageProcessingWorker {
  constructor() {
    this.isProcessing = false;
    this.processedCount = 0;
    console.log('üñºÔ∏è ImageProcessingWorker initialized in worker thread');
  }

  /**
   * –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ URL –∏–ª–∏ file_id
   */
  async downloadImage(imageData) {
    try {
      let imageUrl;
      
      if (imageData.file_id) {
        // –ï—Å–ª–∏ —ç—Ç–æ Telegram file_id, –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å URL —á–µ—Ä–µ–∑ Bot API
        // –î–ª—è worker thread –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π URL –µ—Å–ª–∏ –æ–Ω –ø–µ—Ä–µ–¥–∞–Ω
        if (imageData.file_url) {
          imageUrl = imageData.file_url;
        } else {
          throw new Error('File URL not provided for worker thread');
        }
      } else if (imageData.url) {
        imageUrl = imageData.url;
      } else {
        throw new Error('No valid image source provided');
      }

      const response = await axios.get(imageUrl, {
        responseType: 'arraybuffer',
        timeout: PROCESSING_CONFIG.downloadTimeout,
        maxContentLength: 50 * 1024 * 1024, // 50MB max
        headers: {
          'User-Agent': 'TelegramBot/1.0'
        }
      });

      return {
        buffer: Buffer.from(response.data),
        contentType: response.headers['content-type'],
        size: response.data.byteLength
      };
      
    } catch (error) {
      throw new Error(`Image download failed: ${error.message}`);
    }
  }

  /**
   * –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Ä–∞–∑–º–µ—Ä—ã, —Ñ–æ—Ä–º–∞—Ç, –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ)
   */
  async analyzeImage(imageBuffer) {
    try {
      const image = sharp(imageBuffer);
      const metadata = await image.metadata();
      
      const analysis = {
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
        size: metadata.size,
        channels: metadata.channels,
        hasAlpha: metadata.hasAlpha,
        orientation: metadata.orientation,
        colorSpace: metadata.space,
        density: metadata.density,
        
        // –í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
        aspectRatio: metadata.width / metadata.height,
        megapixels: (metadata.width * metadata.height) / 1000000,
        isLandscape: metadata.width > metadata.height,
        isPortrait: metadata.height > metadata.width,
        isSquare: Math.abs(metadata.width - metadata.height) < 10,
        
        // –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞
        qualityScore: this.calculateQualityScore(metadata),
        
        // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        optimizationSuggestions: this.getOptimizationSuggestions(metadata)
      };

      return analysis;
      
    } catch (error) {
      throw new Error(`Image analysis failed: ${error.message}`);
    }
  }

  /**
   * –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  async optimizeImage(imageBuffer, options = {}) {
    try {
      const {
        maxWidth = PROCESSING_CONFIG.maxWidth,
        maxHeight = PROCESSING_CONFIG.maxHeight,
        quality = PROCESSING_CONFIG.quality,
        format = 'jpeg',
        progressive = true
      } = options;

      let pipeline = sharp(imageBuffer);
      const metadata = await pipeline.metadata();

      // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
      if (metadata.width > maxWidth || metadata.height > maxHeight) {
        pipeline = pipeline.resize(maxWidth, maxHeight, {
          fit: 'inside',
          withoutEnlargement: true
        });
      }

      // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç–∞ –∏ –∫–∞—á–µ—Å—Ç–≤–∞
      switch (format.toLowerCase()) {
        case 'jpeg':
        case 'jpg':
          pipeline = pipeline.jpeg({ 
            quality, 
            progressive,
            mozjpeg: true 
          });
          break;
          
        case 'png':
          pipeline = pipeline.png({ 
            compressionLevel: 9,
            progressive
          });
          break;
          
        case 'webp':
          pipeline = pipeline.webp({ 
            quality,
            effort: 6
          });
          break;
          
        default:
          pipeline = pipeline.jpeg({ quality, progressive });
      }

      const optimizedBuffer = await pipeline.toBuffer();
      const optimizedMetadata = await sharp(optimizedBuffer).metadata();

      return {
        buffer: optimizedBuffer,
        originalSize: metadata.size,
        optimizedSize: optimizedMetadata.size,
        compressionRatio: ((metadata.size - optimizedMetadata.size) / metadata.size * 100).toFixed(2),
        dimensions: {
          original: { width: metadata.width, height: metadata.height },
          optimized: { width: optimizedMetadata.width, height: optimizedMetadata.height }
        }
      };
      
    } catch (error) {
      throw new Error(`Image optimization failed: ${error.message}`);
    }
  }

  /**
   * –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–≤—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  async createThumbnail(imageBuffer, size = PROCESSING_CONFIG.thumbnailSize) {
    try {
      const thumbnailBuffer = await sharp(imageBuffer)
        .resize(size, size, {
          fit: 'cover',
          position: 'center'
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      return {
        buffer: thumbnailBuffer,
        size: thumbnailBuffer.length,
        dimensions: { width: size, height: size }
      };
      
    } catch (error) {
      throw new Error(`Thumbnail creation failed: ${error.message}`);
    }
  }

  /**
   * –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (OCR)
   */
  async extractText(imageBuffer) {
    try {
      // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è OCR
      const processedBuffer = await sharp(imageBuffer)
        .grayscale()
        .normalize()
        .sharpen()
        .toBuffer();

      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É OCR –∫–∞–∫ tesseract.js
      // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–æ–∫-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
      const mockText = 'OCR functionality requires tesseract.js integration';
      
      return {
        text: mockText,
        confidence: 0.85,
        processedImageSize: processedBuffer.length,
        language: 'en'
      };
      
    } catch (error) {
      throw new Error(`Text extraction failed: ${error.message}`);
    }
  }

  /**
   * –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
   */
  async detectObjects(imageBuffer) {
    try {
      const metadata = await sharp(imageBuffer).metadata();
      
      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å TensorFlow.js –∏–ª–∏ –¥—Ä—É–≥—É—é ML –±–∏–±–ª–∏–æ—Ç–µ–∫—É
      // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–Ω–∞–ª–∏–∑ –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
      const objects = [];
      
      // –ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (metadata.channels >= 3) {
        objects.push({
          type: 'colored_image',
          confidence: 0.95,
          description: 'Colored image detected'
        });
      }
      
      if (metadata.width > metadata.height * 1.5) {
        objects.push({
          type: 'landscape',
          confidence: 0.9,
          description: 'Landscape orientation detected'
        });
      }
      
      if (metadata.density && metadata.density > 200) {
        objects.push({
          type: 'high_quality',
          confidence: 0.8,
          description: 'High resolution image'
        });
      }

      return {
        objects,
        imageProperties: {
          colorSpace: metadata.space,
          hasAlpha: metadata.hasAlpha,
          aspectRatio: metadata.width / metadata.height
        },
        processingTime: Date.now()
      };
      
    } catch (error) {
      throw new Error(`Object detection failed: ${error.message}`);
    }
  }

  /**
   * –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  async processImage(imageData, processingOptions = {}) {
    const startTime = Date.now();
    this.isProcessing = true;
    
    try {
      const {
        includeAnalysis = true,
        includeOptimization = true,
        includeThumbnail = true,
        includeTextExtraction = false,
        includeObjectDetection = false,
        optimizationOptions = {}
      } = processingOptions;

      console.log(`üîÑ Starting image processing: ${imageData.file_id || imageData.url}`);

      // 1. –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      const downloadResult = await this.downloadImage(imageData);
      console.log(`üì• Image downloaded: ${downloadResult.size} bytes`);

      const results = {
        downloadInfo: {
          size: downloadResult.size,
          contentType: downloadResult.contentType
        },
        processingTime: {
          download: Date.now() - startTime
        }
      };

      // 2. –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (includeAnalysis) {
        const analysisStart = Date.now();
        results.analysis = await this.analyzeImage(downloadResult.buffer);
        results.processingTime.analysis = Date.now() - analysisStart;
        console.log(`üîç Analysis completed: ${results.analysis.width}x${results.analysis.height}`);
      }

      // 3. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (includeOptimization) {
        const optimizationStart = Date.now();
        results.optimization = await this.optimizeImage(downloadResult.buffer, optimizationOptions);
        results.processingTime.optimization = Date.now() - optimizationStart;
        console.log(`‚ö° Optimization completed: ${results.optimization.compressionRatio}% reduction`);
      }

      // 4. –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–≤—å—é
      if (includeThumbnail) {
        const thumbnailStart = Date.now();
        results.thumbnail = await this.createThumbnail(downloadResult.buffer);
        results.processingTime.thumbnail = Date.now() - thumbnailStart;
        console.log(`üñºÔ∏è Thumbnail created: ${results.thumbnail.size} bytes`);
      }

      // 5. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
      if (includeTextExtraction) {
        const textStart = Date.now();
        results.textExtraction = await this.extractText(downloadResult.buffer);
        results.processingTime.textExtraction = Date.now() - textStart;
        console.log(`üìù Text extraction completed`);
      }

      // 6. –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
      if (includeObjectDetection) {
        const detectionStart = Date.now();
        results.objectDetection = await this.detectObjects(downloadResult.buffer);
        results.processingTime.objectDetection = Date.now() - detectionStart;
        console.log(`üéØ Object detection completed: ${results.objectDetection.objects.length} objects`);
      }

      // –û–±—â–µ–µ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
      results.processingTime.total = Date.now() - startTime;
      this.processedCount++;

      console.log(`‚úÖ Image processing completed in ${results.processingTime.total}ms (total processed: ${this.processedCount})`);

      return results;
      
    } catch (error) {
      console.error(`‚ùå Image processing failed: ${error.message}`);
      throw error;
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  calculateQualityScore(metadata) {
    let score = 50; // –ë–∞–∑–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞
    
    // –û—Ü–µ–Ω–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è
    const megapixels = (metadata.width * metadata.height) / 1000000;
    if (megapixels > 8) score += 20;
    else if (megapixels > 3) score += 15;
    else if (megapixels > 1) score += 10;
    else score -= 10;
    
    // –û—Ü–µ–Ω–∫–∞ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
    if (metadata.density > 300) score += 15;
    else if (metadata.density > 150) score += 10;
    else if (metadata.density > 72) score += 5;
    
    // –û—Ü–µ–Ω–∫–∞ —Ü–≤–µ—Ç–Ω–æ—Å—Ç–∏
    if (metadata.channels >= 3) score += 10;
    if (metadata.hasAlpha) score += 5;
    
    return Math.min(100, Math.max(0, score));
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
   */
  getOptimizationSuggestions(metadata) {
    const suggestions = [];
    
    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–∞–∑–º–µ—Ä—É
    if (metadata.width > 2048 || metadata.height > 2048) {
      suggestions.push('–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–º–µ–Ω—å—à–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–æ 2048px –ø–æ –±–æ–ª—å—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ');
    }
    
    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ñ–æ—Ä–º–∞—Ç—É
    if (metadata.format === 'png' && !metadata.hasAlpha) {
      suggestions.push('–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ JPEG –º–æ–∂–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–º–µ–Ω—å—à–∏—Ç—å —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞');
    }
    
    if (metadata.format === 'bmp' || metadata.format === 'tiff') {
      suggestions.push('–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç (JPEG/WebP) —É–º–µ–Ω—å—à–∏—Ç —Ä–∞–∑–º–µ—Ä');
    }
    
    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∫–∞—á–µ—Å—Ç–≤—É
    if (metadata.density > 300) {
      suggestions.push('–£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –¥–æ 150-200 DPI –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç —Ä–∞–∑–º–µ—Ä');
    }
    
    return suggestions;
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ worker thread
   */
  getWorkerStats() {
    return {
      isProcessing: this.isProcessing,
      processedCount: this.processedCount,
      memoryUsage: process.memoryUsage(),
      uptime: process.uptime()
    };
  }
}

// –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä worker –∏ expose –µ–≥–æ –º–µ—Ç–æ–¥—ã
const imageWorker = new ImageProcessingWorker();

expose({
  processImage: (imageData, options) => imageWorker.processImage(imageData, options),
  analyzeImage: (imageBuffer) => imageWorker.analyzeImage(imageBuffer),
  optimizeImage: (imageBuffer, options) => imageWorker.optimizeImage(imageBuffer, options),
  createThumbnail: (imageBuffer, size) => imageWorker.createThumbnail(imageBuffer, size),
  extractText: (imageBuffer) => imageWorker.extractText(imageBuffer),
  detectObjects: (imageBuffer) => imageWorker.detectObjects(imageBuffer),
  getWorkerStats: () => imageWorker.getWorkerStats()
});

console.log('üöÄ ImageProcessingWorker thread started and ready');
